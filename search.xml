<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[朴素贝叶斯-新闻文本分类]]></title>
      <url>%2F2017%2F09%2F09%2F%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E2%80%94-%E6%96%B0%E9%97%BB%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%2F</url>
      <content type="text"><![CDATA[「朴素贝叶斯」具体理论就不详细讲解了，网上一搜一大把。其核心思想就是： 朴素贝叶斯 = 条件独立假设 + 贝叶斯方法。运行速度快，在满足分布独立这一假设条件下分类效果好，但对于训练集中没有出现过的词语要平滑处理，数值型变量特征默认符合正态分布。 「Python实现」导入停用词导入停用词库，同时使用strip()方法剔除不需要的空白符，包括（&#39;\n&#39;, &#39;\r&#39;, &#39;\t&#39;, &#39; &#39;）12345678def make_word_set(words_file): words_set = set() with codecs.open(words_file,'r','utf-8') as fp: for line in fp: word = line.strip() if len(word) &gt; 0 and word not in words_set: words_set.add(word) return words_set 文本处理，样本生成每个新闻文本txt文件在各自所属类别的文件夹中，结构如下： “folder_path” ｜ ｜－－ C000008 －－ 1.txt / 2.txt / … / 19.txt ｜－－ C000010 ｜－－ C000013 ｜－－ … ｜－－ C000024 这里使用os.listdir()读取指定目录下的所有文件夹名（即分类类别），遍历各自文件夹（类别）内的文本文件，对每一个txt文件进行文本切词，同时利用zip()函数使每个新闻文本与所属类别一一对应，一共有90条数据。 为了随机抽取训练与测试数据集，用random.shuffle()打乱顺序，并选取20%的数据用于测试，同时把特征数据与类别数据各自分开。 最后对训练数据集中的词语进行词频统计。这里有使用sorted()函数进行排序，方法为sorted(iterable, cmp = None, key = None, reverse = False)，其中参数含义如下： iterable：是可迭代类型（我这里的可迭代类型为字典） cmp：用于比较的函数，比较什么由key决定（这里没用到） key：用列表元素的某个属性或函数进行作为关键字（这里使用字典中的“值”大小作为关键字排序） reverse：排序规则，True为降序（False为升序） 12345678910111213141516171819202122232425262728293031323334353637383940414243def text_processing(folder_path, test_size = 0.2): folder_list = os.listdir(folder_path) data_list = [] class_list = [] # 遍历文件夹 for folder in folder_list: new_folder_path = os.path.join(folder_path,folder) files = os.listdir(new_folder_path) j = 1 for file in files: if j &gt; 100: # 防止内存爆掉 break with codecs.open(os.path.join(new_folder_path, file), 'r', 'utf-8') as fp: raw = fp.read() word_cut = jieba.cut(raw, cut_all = False) word_list = list(word_cut) data_list.append(word_list) # 训练集 class_list.append(folder) # 类别 j += 1 # 划分训练集和测试集 data_class_list = list(zip(data_list, class_list)) random.shuffle(data_class_list) # 打乱顺序 index = int(len(data_class_list) * test_size) + 1 # 抽取测试数据集的占比 train_list = data_class_list[index:] test_list = data_class_list[:index] train_data_list,train_class_list = zip(*train_list) # 特征与标签 test_data_list,test_class_list = zip(*test_list) # 统计词频 all_words_dict = &#123;&#125; for word_list in train_data_list: for word in word_list: if word in all_words_dict: all_words_dict[word] += 1 else: all_words_dict[word] = 1 # 降序排序（key函数） all_words_tuple_list = sorted(all_words_dict.items(),key = lambda f:f[1], reverse = True) all_words_list = list(zip(*all_words_tuple_list))[0] return all_words_list, train_data_list, test_data_list, train_class_list, test_class_list 特征选择这里我们仅选取词频坐高的1000个特征词（维度），并剔除数字与停用词。12345678910def words_dict(all_words_list,deleteN,stopwords_set=set()): feature_words = [] n = 1 for t in range(deleteN,len(all_words_list),1): if n &gt; 1000: # 最多取1000个维度 break if not all_words_list[t].isdigit() and all_words_list[t] not in stopwords_set and 1 &lt; len(all_words_list[t]) &lt; 5: feature_words.append(all_words_list[t]) n += 1 return feature_words 用选取的特征词构建0-1矩阵对训练数据集train_data_list中每篇切完词之后的文档构建特征向量（由上述1000个特征词组成），若出现则取值为1，否则为0。于是90篇文章构建出了[90,1000]维度的0-1矩阵（其中71行为训练数据，19行为测试数据）。 训练集如下： 0-1矩阵如下： 1234567891011def text_features(train_data_list, test_data_list, feature_words): def text_features(text,feature_words): # text = train_data_list[0] text_words = set(text) features = [1 if word in text_words else 0 for word in feature_words] return features # 0,1的矩阵（1000列-维度） train_feature_list = [text_features(text, feature_words) for text in train_data_list] test_feature_list = [text_features(text, feature_words) for text in test_data_list] return train_feature_list,test_feature_list 朴素贝叶斯分类器这里使用开源sklearn库中的朴素贝叶斯分类器，输入参数分别为训练集的0-1特征矩阵（train_feature_list）与训练集分类（train_class_list），然后对测试数据的输出与真实结果进行比较，得到准确度为0.68 12345def text_classifier(train_feature_list,test_feature_list,train_class_list,test_class_list): # sklearn多项式分类器 classifier = MultinomialNB().fit(train_feature_list,train_class_list) # 特征向量与类别 test_accuracy = classifier.score(test_feature_list,test_class_list) return test_accuracy 这里我们仅选取词频最高的1000个作为特征向量，不妨尝试下选取其他的关键字作为特征向量，发现准确率都在0.63以上，分类效果还算可以，见下图： 12345678910111213141516171819202122232425262728293031if __name__ == '__main__': # 文本预处理（分词、划分训练与测试集、排序） folder_path = '...' all_words_list, train_data_list, test_data_list, train_class_list, test_class_list = text_processing(folder_path, test_size = 0.2) # stopwords_set stopwords_file = '...' stopwords_set = make_word_set(stopwords_file) # 特征提取与分类 deleteNs = range(0,1000,20) test_accuracy_list = [] for deleteN in deleteNs: # 选取1000个特征 feature_words = words_dict(all_words_list,deleteN,stopwords_set) # 计算特征向量 train_feature_list, test_feature_list = text_features(train_data_list,test_data_list,feature_words) # sklearn分类器计算准确度 test_accuracy = text_classifier(train_feature_list,test_feature_list,train_class_list,test_class_list) # 不同特征向量下的准确度 test_accuracy_list.append(test_accuracy) print(test_accuracy_list) # 结果评价 plt.figure() plt.plot(deleteNs,test_accuracy_list) plt.title('Relationship of deleteNs and test_accuracy') plt.xlabel('deleteNs') plt.ylabel('test_accuracy') plt.savefig('result.png',dpi = 100) plt.show() 「参考资料」 用朴素贝叶斯进行文本分类朴素贝叶斯分类器的应用]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《小岛经济学》读书笔记（四）]]></title>
      <url>%2F2017%2F08%2F26%2F%E3%80%8A%E5%B0%8F%E5%B2%9B%E7%BB%8F%E6%B5%8E%E5%AD%A6%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
      <content type="text"><![CDATA[量化宽松其本质是向金融市场注入新的资金，来推动价格上涨。实际上，就是通货膨胀的委婉说法，是将政府债务货币化的隐秘手段。文中作者把它比喻成用汽油去救火，汽油越多，火势也就越大。如果不知道汽油是可燃物，我们也许会得出这样的结论：火没有被扑灭是因为汽油的量还不够大。 总结与启示作者对于经济的核心思想：需求才是促进经济增长的真正动力，而非消费。增大货币量固然会鼓励人们消费，但对扩大需求毫无裨益。 构建属于自己的捕鱼器并不断优化资本（工具）的产生提高了产出与效率，让你有更多的储蓄与时间做更有创造力的事情。对于我们自身，应该建立自己的专业性与知识体系，而非像徒手捕鱼的渔民，陷入低产出的工作中。 重视储蓄的价值了解自身的收入与支出，合理并结构化自己的支出与储蓄比例。但是有的消费却不能省，如孝顺父母的钱，对自己的投资（ROI是最大的）。 了解市场/行业的供需关系你的价值是根据市场需求来决定的。符合市场需求并且稀缺，那么你的价值就越大。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《小岛经济学》读书笔记（三）]]></title>
      <url>%2F2017%2F07%2F31%2F%E3%80%8A%E5%B0%8F%E5%B2%9B%E7%BB%8F%E6%B5%8E%E5%AD%A6%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
      <content type="text"><![CDATA[第七~十一章自由贸易的优势扩大的选择范围（进口的T恤比本土要便宜），可以让美国人花更少的钱在T恤上。而省下来的钱可用于生产其他东西，这对于那些能输送最有价值产品的公司也是有利的。 由于本土的（T恤）企业无法找到竞争优势，工人会下岗。但经济的目的并非提供就业岗位，而是不断提高生产力。浪费劳动力制造那些国外生产率更高的产品是毫无意义的，应该找到自己更具优势的行业（更擅长制造的产品）。 关于美联储1913年，美联储成立，发行纸币，并承诺持有者可以随时兑换黄金。其最初目的是“弹性货币供应”：根据经济活动的情况，扩大或收紧货币的流通量，从而让物价保持平稳，不收繁荣或萧条的影响。 然而过去的100年里，物价上涨、货币的贬值（货币购买力下降），美元损失了超过95%的价值。美国人手里仅持有一种没有实际价值且可以随意增发的货币。 通货膨胀岛上捕鱼的增长率远低于发行纸币的增长率，于是“通鱼膨胀”的难题产生了，物价上涨。 很多人认为物价上涨就是通货膨胀，其实不然，上涨的价格只是通货膨胀的结果罢了。通货膨胀其实就是货币供应量增加，货币紧缩就是货币供应量收紧。 政府面对经济衰退的本能反应是造更多的纸币，因为经济学家认为物价下跌会导致经济陷入需求崩溃的万丈深渊。但事实是，物价需要下跌才能平衡正在衰退的经济局势。当经济不景气时，人们会停止消费，物价下跌。当跌到一定程度，人们又会开始消费。整个过程淘汰了不必要的产能，并把物价调整到了符合内在供求关系的水平。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《小岛经济学》读书笔记（二）]]></title>
      <url>%2F2017%2F07%2F26%2F%E3%80%8A%E5%B0%8F%E5%B2%9B%E7%BB%8F%E6%B5%8E%E5%AD%A6%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
      <content type="text"><![CDATA[第五、六章生产效率由于生产效率的提升（储蓄、创新与投资的结果），产品的价格也随之下降，于是更多的顾客可以去消费购买，昔日的奢侈品也成了普通消费品。 工作与薪资由于岛上经济的多样化与社会分工的加剧，大多数劳动者会选择为别人工作（就业），用劳动换取报酬（薪资）。那么如何衡量劳动者的劳动价值？ 需求 供应 生产效率 所以想要获得较高的薪资，必须要提高自身价值，要么掌握稀缺的能力，要么通过刻意练习提高工作效率与熟练度。 利率政府不但可以通过政策的倾向性扰乱信贷市场，还可以通过操控利率影响信贷市场。政府被授予这一权利的背后是为了保证经济的平稳运行（无论是繁荣还是萧条期）。其理论基础是：美联储的经济学家能运用集体智慧，推算出特定时点最理想的利率水平，从而使经济正常运行。 但这一机制有两个致命的缺陷： 美联储与利率没有任何关系，既不产生储蓄，也不为坏账而蒙受损失。没有这种关联，真的能比市场更清楚什么事恰当的利率水平么？ 美联储的决定基于政治考量多于经济因素。因为低利率能让经济表面上表现更好。但事实是，过低的利率会传达出错误的信号，误以为经济状态良好、投资可行。结果就是虚假的繁荣之后出现巨大的危机。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《小岛经济学》读书笔记（一）]]></title>
      <url>%2F2017%2F07%2F24%2F%E3%80%8A%E5%B0%8F%E5%B2%9B%E7%BB%8F%E6%B5%8E%E5%AD%A6%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
      <content type="text"><![CDATA[第一、二章：工具的出现改变了一切关于资本与储蓄资本（设备）的建设与使用本身并没有什么意义，价值在于利用资本制造所需之物。同时带来的是生产力的提高，从而获得储蓄与积累（剩余价值）。 关于经济最基本的定义：努力使有限的资源来产生最大的效益，尽可能满足人类的需求。工具、资本、创新是实现这一目标的关键。 经济增长的原因：找到了生产人类所需物品的更好方式。 关于财富财富从来就是一个相对的概念。有人认为现在的贫富差距越来越大，但我们也要同时看到好的一面。整个社会的财富在变多，以前只有富人才能坐的起马车，现在基本人人都有能力买车，唯一区别在于品牌。即便是在中世纪最至高无上的国王眼里也是缺乏的各类娱乐设施，在如今的社会几乎人人都能享受。 富人真正致富的原因是为他人提供有价值的东西并承担一定的风险，文中艾伯不工作获得的利润是对他出借储蓄（鱼）所承风险的补偿（不还鱼）。 总结成一句话工具提高生产力，生产力提高了，获得剩余价值，剩余价值引发借贷，借贷产生经济，经济发展促进财富积累。 第三、四章：该不该存钱？积累储蓄的重要性 提高个人的消费能力，实现人生更多可能的方式，比如所走就走的一场旅行。 防止经济受到意外因素的缓冲器。 消费与储蓄消费是只是用来衡量生产的尺度，因为生产的最终目的是消费。为了消费而消费并不会推动经济增长，就如花了100万买了一堆空气（并不是你真正需要的），虽然这100万算进了GDP中(同时表明不能仅用GDP来衡量经济是否增长)。必须要生产出有价值的东西（人们需要的），才能使消费有价值，经济才能增长。 然而储蓄创造了资本，资本使生产扩大成为了可能。所以从某种意义上，储蓄起来的一美元对经济产生的积极影响要大于消费掉的一美元。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[天姥徒步行]]></title>
      <url>%2F2017%2F05%2F30%2F%E5%A4%A9%E5%A7%A5%E5%BE%92%E6%AD%A5%E8%A1%8C%2F</url>
      <content type="text"><![CDATA[「序」海客谈瀛洲，烟涛微茫信难求。越人语天姥，云霞明灭或可睹…… 这首太白诗中的天姥山便是我们此行的目的地。 「随便说些什么」四个小伙伴跟随着稻草人的步伐，来了次虐身的登山~~~（谁让我们平时没怎么锻炼） #Day 1解决了午饭，顺利抵达山脚，开始此次登山之旅。 上山走累了，便随地憩息。清泉真的好冰凉，直接饮用也无碍。 沿途的风景让人回归自然，心情舒畅，一片盎然生机的景象。 感觉就如李太白所说“身登青云梯”这种感觉 晚上的“狼人杀”欢乐多多，尤其是我左右两边的女巫与预言家，你们要给力、好好带队啊~ 看着浩瀚的星空，渐渐入睡…… #Day 2第二天早上补充能量之后，开始了崎岖的下山之旅。 你在桥上看风景，看风景的人在楼上看你。 明月装饰了你的窗， 而你装饰了别人的梦。 爱笑的女生运气总不会太差 游览沃洲湖 这一刻的定焦，希望能保持永远永远 最后放上笑得有点傻傻、永远18岁的giver! 「后记」恰同学少年，风华正茂，书生意气，挥斥方遒。指点江山，激扬文字，粪土当年万户侯。愿我们始终怀有一颗赤子之心。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[D3学习系列（三） 桑基图]]></title>
      <url>%2F2017%2F04%2F15%2FD3%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89-%E6%A1%91%E5%9F%BA%E5%9B%BE%2F</url>
      <content type="text"><![CDATA[「前言」网上关于桑基图的例子也有一些，但是对于初入门的新手并不友好、易懂。如果仅用百度搜索，资料更是少得可怜（这里感谢同事推荐shadowsocks进行科学上网●^●）。当然有些语句没有看懂，anyway先实现了再说~ 「什么是桑基图」桑基图（Sankey diagram），即桑基能量分流图，主要是用来描述能量、人口、经济等的流动情况。因1898年Matthew Henry Phineas Riall Sankey绘制的“蒸汽机的能源效率图”而闻名，此后便以其名字命名为“桑基图”。 桑基图主要关注能量、物料或资本等在系统内部的流动和转移情况。Sankey diagram的特点有： 起始流量和结束流量相同 在内部，不同的线条代表了不同的流量分流情况，它的宽度成比例地显示此分支占有的流量 节点不同的宽度代表了特定状态下的流量大小 在数据可视化中，桑基图有利于展现分类维度间的相关性，以流的形式呈现共享同一类别的元素数量。特别适合表达集群的发展，比如展示特定群体的人数分布等。我们可以欣赏下利用桑基图展示的可视化作品，太美了简直！ 「绘制桑基图」绘制画布SVG123456789101112131415var margin = &#123;top: 1, right: 1, bottom: 6, left: 1&#125;, width = 1000 - margin.left - margin.right, height = 650 - margin.top - margin.bottom;var formatNumber = d3.format(",.0f"), // 数字转字符串 逗号分隔，0位小数点 format = function(d) &#123;return formatNumber(d) + "m CHF";&#125;;var color = d3.scale.category20();var svg = d3.select("#chart")//ID选择器 .append("svg") .attr("width", width + margin.left + margin.right) .attr("height", height + margin.top + margin.bottom) .append("g") .attr("transform", "translate(" + margin.left + "," + margin.top + ")"); 在body中定义一个&lt;p&gt;元素，令id=&quot;chart&quot;，画布SVG作用在元素&lt;p&gt;中，保持有一定的margin。 定义桑基布局123456var sankey = d3.sankey() .nodeWidth(25) // 节点宽度 .nodePadding(20) // 矩形垂直方向的间距 .size([width,height]);var path = sankey.link(); sankey.link()函数应该是插件sankey.js中定义好的，目的是生成节点相对应的路径。 绑定数据123456d3.json("http://benlogan1981.github.io/VerticalSankey/data/ubs.json", function(error, energy) &#123; sankey .nodes(energy.nodes) // 绑定节点数据 .links(energy.links) // 绑定路径数据 .layout(32); // iterations ?&#125;; 这里我们通过引用外部JS数据的方式来绑定，之后直接使用energy.的方式调用，方式如下：d3.json(&quot;XXX.json&quot;, function(error, energy) {}; 注意如果不启动外部服务器，是没有办法加载外部数据的。由于Python自带的包可以建立简单的Web服务器，便直接用Python： 命令行中直接CD到准备做服务器的根目录下，输入命令：python -m SimpleHTTPServer 8080（这里使用的2.X版本，3.X版本稍有不同） 然后就可以在浏览器中输入：http://localhost:8080/路径来访问服务器的资源 JSON数据这里的JSON数据长这样： {“nodes”:[{“name”:”Wealth Management”},{“name”:”WMA”},…{“name”:”Switzerland”}],“links”:[{“source”:0,”target”:5,”value”:100},{“source”:1,”target”:5,”value”:1800},….{“source”:4,”target”:8,”value”:400}]} nodes表示节点数据；links表示连线数据，其中source为起始节点，target表示终点节点，value为量的大小。关于.layout()，查了相关资料，好像是跟计算出来的节点与路径数据的迭代次数（iterations）有关，但是调整参数值并没有发现什么变化。 绘制路径数据links123456789101112131415161718192021var link = svg.append("g").selectAll("path") .data(energy.links) .enter() .append("path") .attr("class","link") .attr("d",path) // 路径链接已被sankey封装好 .style("stroke-width",function(d)&#123; return Math.max(1,d.dy); &#125;) .style("stroke",function(d) &#123; return d.source.color = color(d.source.name.replace(/ .*/,"")); &#125;) .sort(function(a,b)&#123; return b.dy - a.dy; &#125;) ;link.append("title") .text(function(d)&#123; return d.source.name + "-&gt;" + d.target.name + "\n" + format(d.value) ; &#125;); stroke-width参数表示links的宽度，返回的是1和dy中的最大值，但大部分情况都会返回dy。如果换成10（这样每根连线都是一样宽度），看一下效果就知道stroke-width的作用了： stroke其实是描边的意思，感觉由于header部分设置过了fill：none，所以才默认为填充的颜色。这里设置相同起始节点的连线具有相同的颜色，确保达到你想要颜色分类的效果。同时对每条links添加title，鼠标悬停会显示相应内容。 绘制节点数据nodes123456789101112131415161718192021222324252627282930313233343536var node = svg.append("g").selectAll("g") .data(energy.nodes) .enter() .append("g") .attr('class', "node") .attr('transform', function(d)&#123; return "translate(" + d.x + "," + d.y + ")"; //节点的(x,y)坐标 &#125;);node.append("rect") .attr("height",sankey.nodeWidth()) .attr("width",function(d) &#123; return d.dy; &#125;) .style("fill",function(d) &#123; return d.color = color(d.name.replace(/ .*/, "")); &#125;) .style("stroke",function(d) &#123; return d3.rgb(d.color).darker(2); &#125;) .append("title") .text(function(d) &#123; return d.name + "\n" + format(d.value) ; &#125;);node.append("text") .attr("text-anchor","middle") .attr("x",function(d) &#123; return d.dy/2; &#125;) .attr("y",function(d) &#123; sankey.nodeWidth() / 2; &#125;) .attr("dy","1em") .text(function(d) &#123; return d.name; &#125;) .filter(function(d) &#123; return d.x &lt; width / 2 ; &#125;); 每个rect元素的高度(height)相同，宽度(width)为相应的dy；stroke把外框颜色设置成与rect元素同样的颜色并加深，图片放大可以明显的看出效果），.text添加鼠标悬停显示相应文字，效果如下： 添加交互效果1.用CSS控制悬浮样式，让连接线在鼠标悬停的时候高亮显示：12345&lt;style &gt; .link:hover &#123; stroke-opacity: .8; &#125;&lt;/style&gt; 2.节点添加拖动事件 定义一个拖动事件，这里仅限于水平方向的移动，移动之后重新布局并生成行的路径 1234567function dragmove(d) &#123; d3.select(this) .attr("transform","translate(" + (d.x = Math.max(0,Math.min(width - d.dy, d3.event.x))) + "," + d.y + ")") ; sankey.relayout(); // 重新布局 link.attr("d",path);&#125; 对node节点添加事件 123456789node.call(d3.behavior.drag() //这一段只知道大概是什么意思 .origin(function(d)&#123; return d; &#125;) .on("dragstart",function() &#123; this.parentNode.appendChild(this); &#125;) .on("drag",dragmove) ); 好了，现在我们就可以做出首页第一张sankey图的效果了，最后再附上自己做的另一张横版sankey图（好像是由于sankey.js插件的问题，导致横竖排版） 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="js/d3.js" charset="utf-8"&gt;&lt;/script&gt; &lt;script src="js/d3-sankey-1.js" charset="utf-8"&gt;&lt;/script&gt; &lt;style &gt; body &#123; background-color: white; &#125; #chart &#123; height: 650px; /* must at least match the svg, to place content after it!*/ &#125; .node rect &#123; cursor: move; fill-opacity: .9; shape-rendering: crispEdges; &#125; .node text &#123; pointer-events: none; text-shadow: 0 1px 0 #fff; &#125; .link &#123; fill: none; /*stroke: #000;*/ stroke-opacity: .5; &#125; .link:hover &#123; stroke-opacity: .8; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p id="chart"&gt;&lt;/p&gt; &lt;script&gt; var margin = &#123;top: 1, right: 1, bottom: 6, left: 1&#125;, width = 1000 - margin.left - margin.right, height = 650 - margin.top - margin.bottom; var formatNumber = d3.format(",.0f"), // 数字转字符串 逗号分隔，0位小数点 format = function(d) &#123;return formatNumber(d) + "m CHF";&#125;; var color = d3.scale.category20(); var svg = d3.select("#chart")//ID选择器 .append("svg") .attr("width", width + margin.left + margin.right) .attr("height", height + margin.top + margin.bottom) .append("g") .attr("transform", "translate(" + margin.left + "," + margin.top + ")") ; // 布局 var sankey = d3.sankey() .nodeWidth(25) // 节点宽度 .nodePadding(20) // 矩形垂直方向的间距 .size([width,height]) // .nodes(data.nodes) // .links(data.links) // .layout(3) ; var path = sankey.link(); console.log(path); d3.json("http://benlogan1981.github.io/VerticalSankey/data/ubs.json", function(error, energy) &#123; sankey .nodes(energy.nodes) .links(energy.links) .layout(32); var link = svg.append("g").selectAll("path") .data(energy.links) .enter() .append("path") .attr("class","link") .attr("d",path) // 路径链接已被sankey封装好 .style("stroke-width",function(d)&#123; return Math.max(1,d.dy); &#125;) // .style("stroke",function(d) &#123; // console.log(d.source.name.replace(/ .*/,"")); // &#125;) .style("stroke",function(d) &#123; return d.source.color = color(d.source.name.replace(/ .*/,"")); &#125;) .sort(function(a,b)&#123; return b.dy - a.dy; &#125;) ; link.append("title") .text(function(d)&#123; return d.source.name + "-&gt;" + d.target.name + "\n" + format(d.value) ; &#125;); var node = svg.append("g").selectAll("g") .data(energy.nodes) .enter() .append("g") .attr('class', "node") .attr('transform', function(d)&#123; return "translate(" + d.x + "," + d.y + ")"; &#125;) .call(d3.behavior.drag() .origin(function(d)&#123; return d; &#125;) .on("dragstart",function() &#123; this.parentNode.appendChild(this); &#125;) .on("drag",dragmove) ) ; node.append("rect") .attr("height",sankey.nodeWidth()) .attr("width",function(d) &#123; return d.dy; &#125;) .style("fill",function(d) &#123; return d.color = color(d.name.replace(/ .*/, "")); &#125;) .style("stroke",function(d) &#123; return d3.rgb(d.color).darker(2); &#125;) .append("title") .text(function(d) &#123; return d.name + "\n" + format(d.value) ; &#125;) ; node.append("text") .attr("text-anchor","middle") .attr("x",function(d) &#123; return d.dy/2; &#125;) .attr("y",function(d) &#123; sankey.nodeWidth() / 2; &#125;) .attr("dy","1em") .text(function(d) &#123; return d.name; &#125;) .filter(function(d) &#123; return d.x &lt; width / 2 ; &#125;) ; function dragmove(d) &#123; d3.select(this).attr("transform","translate(" + (d.x = Math.max(0,Math.min(width - d.dy, d3.event.x))) + "," + d.y + ")") ; sankey.relayout(); link.attr("d",path); &#125; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 「参考资料」 【D3 Tips and Tricks v4.x】【D3.js数据可视化实战】–（3）桑基图（sankey）的绘制【USB 2015 Q1 Results】]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《大数据与机器学习》读书笔记（二） 应用篇]]></title>
      <url>%2F2017%2F04%2F07%2F%E3%80%8A%E5%A4%A7%E6%95%B0%E6%8D%AE%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89-%E5%BA%94%E7%94%A8%E7%AF%87%2F</url>
      <content type="text"><![CDATA[标签系统 - “空间换时间”作用与意义 避免重复计算，提高查询效率 降低数据使用成本 层次结构整个标签系统可分为多个主题（信用卡系统中的客户主题、卡片主题等），每个主题下又可根据标签数据的来源分为三类（基础类、行为类与衍生类） 基础类：如客户的基本信息，无需二次加工 行为类：如客户的历史行为（近一个月投资金额等），需要二次加工 衍生类：其他标签之间的逻辑组合 更新规则 基础类：静态标签，使用增量更新方式 行为类：动态标签，可采用周期性全量更新 衍生类：不存储标签值，仅存储标签之间的计算逻辑 ，无需更新 数据自助营销平台 - 数据产生价值最直接的途径作用与意义 自动化，提升工作效率 降低营销成本，提高用户体验 个性化营销，提升响应率 e.g. 某一营销活动（为促动低消费频次的客户用卡，提高卡均消费金额），期望不同的客户收到不同的营销短信。可通过营销平台限定仅6个月用卡次数 &lt; 10，月消费1800满3个月（略高于历史上的月均卡均消费），即可获得免费的化妆品（偏好标签）。 统一管理，便于后续效果追踪 其中可以看到，各种营销活动规则下的条件来源于标签系统，所以标签系统是基础！ 实时数据营销除了传统的批量营销方式（如优惠券即将过期短信提醒等），还有一种“基于场景的营销”，如你到加油站加油，刷卡付款后会立马收到某汽车润滑剂的促销信息。 从技术上来看，就是引入“消息队列”（Kafka、ActiveMQ等），将用户基于场景的“动作”转化为一个“消息” 给到数据营销平台，根据匹配的营销规则进行实时处理，反馈结果给客户。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[D3学习系列（二） 弦图绘制]]></title>
      <url>%2F2017%2F03%2F31%2FD3%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89-%E5%BC%A6%E5%9B%BE%E7%BB%98%E5%88%B6%2F</url>
      <content type="text"><![CDATA[「什么时候用弦图」Chord Diagram主要是用来表示多个节点之间的关系，假设我们要表示5个节点之间的关系，那么输入的矩阵是下面这个样子，且必须是方阵。节点A的长度是元素A所在行的总和，就是(A, A)、(A, B)、(A, C)、(A, D)、(A, E)的和。图中C与D之间的弦表示C和D相关，与C相接的弧长实际上是(C, D)的值。 「绘制弦图」导入初始数据12345678var city_name = [ "北京" , "上海" , "广州" , "深圳" , "香港" ];var population = [ [ 1000, 3045 , 4567 , 1234 , 3714 ], [ 3214, 2000 , 2060 , 124 , 3234 ], [ 8761, 6545 , 3000 , 8045 , 647 ], [ 3211, 1067 , 3214 , 4000 , 1006 ], [ 2146, 1034 , 6745 , 4764 , 5000 ] ]; 布局（转换数据）12345678// 弦布局var chord_layout = d3.layout.chord() .padding(0.03) .sortSubgroups(d3.descending) .matrix(population);// 布局转化数据var groups = chord_layout.groups();var chords = chord_layout.chords(); padding(0.03)表示弧与弧之间的间隔，population是之前输入的人口数据。经过布局之后会生成两块，一块是groups，表示节点；另一块是chords，表示弦（连线），chords里面还会分source与target，表示连线的两端。 绘制画布SVG12345678910// svg画布var width = 600;var height = 600;var svg = d3.select("body") .append("svg") .attr("width",width) .attr('height', height) .append("g") .attr('transform', 'translate(' + width/2 + "," + height/2 + ")");var color20 = d3.scale.category20(); 先创建一个SVG元素，里面添加一个g元素同时设置平移属性（用来确定弦图的中心）。然后再在g元素添加2个g元素，分别用来装节点与弦，结构如下所示： &lt;svg&gt; －－&lt;g&gt; －－－－ &lt;g&gt;``&lt;/g&gt; －－－－ &lt;g&gt;``&lt;/g&gt; －－&lt;/g&gt;&lt;/svg&gt; 绘制节点（弧）12345678910111213141516171819202122232425262728293031323334353637383940// 弧生成器var innerRadius = width/2 * 0.7;var outerRadius = innerRadius * 1.1;var outer_arc = d3.svg.arc() .innerRadius(innerRadius) .outerRadius(outerRadius);// 绘制节点var g_outer = svg.append("g");g_outer.selectAll("path") .data(groups) .enter() .append("path") .style("fill",function(d) &#123; return color20(d.index); &#125;) .style("stroke",function(d) &#123; color20(d.index); &#125;) .attr("d",outer_arc) // 此处调用了弧生成器 ;// 节点文字g_outer.selectAll("text") .data(groups) .enter() .append("text") .each(function(d,i) &#123; // 对每个绑定的数据添加两个变量 d.angle = (d.startAngle + d.endAngle) / 2; d.name = city_name[i]; &#125;) .attr("dy",".35em") .attr('transform', function(d) &#123; // 平移属性 var result = "rotate(" + (d.angle*180/Math.PI) + ")"; result += "translate(0," + -1 * (outerRadius + 10) + ")"; if (d.angle &gt; Math.PI * 3 / 4 &amp;&amp; d.angle &lt; Math.PI * 5 / 4 ) result += "rotate(180)"; return result; &#125;) .text(function(d) &#123; return d.name; &#125;); 在标记文字的地方要注意： each()：表示对任何一个绑定数据的元素，都执行后面的无名函数 function(d,i) ，计算文字的角度与内容 transform()：不仅需要考虑文字的旋转角度与平移距离，还要考虑如果文字在下方是会是倒写的情况。 生成如下图： 绘制连线（弦）123456789101112131415161718// 弦生成器var inner_chord = d3.svg.chord() .radius(innerRadius);// 绘制内部弦var g_inner = svg.append("g") .attr("class","chord");g_inner.selectAll("path") .data(chords) .enter() .append("path") .attr("d",inner_chord) // 调用弦的路径值 .style("fill",function(d) &#123; return color20(d.source.index); &#125;) .style("opacity",1) ; 这样就生成了首页的弦图，但是当数据多了之后，会看不清节点与节点之间的关系，我们可以添加一些交互式的操作解决。如当鼠标移到该节点，只会显示与该节点相接的弦，其他的会被隐藏。这里我们定义一个fade函数，并在节点（弧）上通过mouseover与mouseout添加动作123456789101112131415function fade(opacity)&#123; return function(g,i)&#123; g_inner.selectAll("path") .filter(function(d) &#123; return d.source.index != i &amp;&amp; d.target.index != i; &#125;) .transition() .style("opacity",opacity); &#125;&#125;g_outer.selectAll("path") .on("mouseover",fade(0.0)) // 0.0完全透明 .on("mouseout",fade(1.0)) // 1.0完全不透明 ; 效果如图： 「源代码」123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="http://d3js.org/d3.v3.min.js" charset="utf-8"&gt;&lt;/script&gt; &lt;style&gt; .chord path&#123; fill-opacity: 0.67; stroke: #000; stroke-width: 0.5px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; // 初始数据 var city_name = [ "北京" , "上海" , "广州" , "深圳" , "香港" ]; var population = [ [ 1000, 3045 , 4567 , 1234 , 3714 ], [ 3214, 2000 , 2060 , 124 , 3234 ], [ 8761, 6545 , 3000 , 8045 , 647 ], [ 3211, 1067 , 3214 , 4000 , 1006 ], [ 2146, 1034 , 6745 , 4764 , 5000 ] ]; // 弦布局 var chord_layout = d3.layout.chord() .padding(0.03) .sortSubgroups(d3.descending) .matrix(population); // 布局转化数据 var groups = chord_layout.groups(); var chords = chord_layout.chords(); console.log(groups); console.log(chords); // svg画布 var width = 600; var height = 600; var svg = d3.select("body") .append("svg") .attr("width",width) .attr('height', height) .append("g") .attr('transform', 'translate(' + width/2 + "," + height/2 + ")"); var color20 = d3.scale.category20(); // 弧生成器 var innerRadius = width/2 * 0.7; var outerRadius = innerRadius * 1.1; var outer_arc = d3.svg.arc() .innerRadius(innerRadius) .outerRadius(outerRadius); // 绘制节点 function fade(opacity)&#123; return function(g,i)&#123; g_inner.selectAll("path") .filter(function(d) &#123; return d.source.index != i &amp;&amp; d.target.index != i; &#125;) .transition() .style("opacity",opacity); &#125; &#125; var g_outer = svg.append("g"); g_outer.selectAll("path") .data(groups) .enter() .append("path") .style("fill",function(d) &#123; return color20(d.index); &#125;) .style("stroke",function(d) &#123; color20(d.index); &#125;) .attr("d",outer_arc) // 此处调用了弧生成器 .on("mouseover",fade(0.0)) // 0.0完全透明 .on("mouseout",fade(1.0)) // 1.0完全不透明 ; g_outer.selectAll("text") .data(groups) .enter() .append("text") .each(function(d,i) &#123; // 对每个绑定的数据添加两个变量 d.angle = (d.startAngle + d.endAngle) / 2; d.name = city_name[i]; &#125;) .attr("dy",".35em") .attr('transform', function(d) &#123; // 平移属性 var result = "rotate(" + (d.angle*180/Math.PI) + ")"; result += "translate(0," + -1 * (outerRadius + 10) + ")"; if (d.angle &gt; Math.PI * 3 / 4 &amp;&amp; d.angle &lt; Math.PI * 5 / 4 ) result += "rotate(180)"; return result; &#125;) .text(function(d) &#123; return d.name; &#125;); // 弦生成器 var inner_chord = d3.svg.chord() .radius(innerRadius); // 绘制内部弦,一共有5*5=25条 var g_inner = svg.append("g") .attr("class","chord"); g_inner.selectAll("path") .data(chords) .enter() .append("path") .attr("d",inner_chord) // 调用弦的路径值 .style("fill",function(d) &#123; return color20(d.source.index); &#125;) .style("opacity",1) ; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[D3学习系列（一） 基础知识与柱形图绘制]]></title>
      <url>%2F2017%2F03%2F25%2FD3%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8E%E6%9F%B1%E5%BD%A2%E5%9B%BE%E7%BB%98%E5%88%B6%2F</url>
      <content type="text"><![CDATA[「前言」最开始的初衷是想画个弦图（chord）与桑基图（sankey），真的很炫有没有！然而D3零基础的我表示源码看不懂，受到1万点暴击(+﹏+)~ 于是果断去恶补D3的基础知识，并加以整理同时加深对自己的印象。 「基础概念」选择集使用 d3.select() 或 d3.selectAll() 选择元素后返回的对象，就是选择集 无名函数function(d, i) 这个函数以后经常要使用到 d 代表数据，也就是与某元素绑定的数据。 i 代表索引，代表数据的索引号，从 0 开始。 「数据绑定」D3可以用两种函数来绑定数据： datum()： 绑定一个数据到选择集上，这里的数据并非一定要是number（数值型），也可以是string（字符串）、bollean（布尔型）和object（对象） data()： 绑定一个数组到选择集上，数组的各项值分别与选择集的各元素绑定，更常用 data() 函数的常用语法12345678910var dataset = [10,20,30,40,50];var body = d3.select("body");body.selectAll("p") //选择body中的所有p，但是目前还没有，所以是空集 .data(dataset) //绑定数组 .enter() //指定选择集的enter部分 .append("p") .text(function(d)&#123; return d; &#125;) 这里要解释下 Enter 的概念，它与Update、Exit是D3中三个非常重要的概念，处理的是当选择集和数据的数量关系不确定的情况。 如果数组为 [3, 6, 9, 12, 15]，将此数组绑定到三个 p 元素的选择集上。可以想象，会有两个数据没有元素与之对应，这时候 D3 会建立两个空的元素与数据对应，这一部分就称为 Enter。而有元素与数据对应的部分称为 Update。如果数组为 [3]，则会有两个元素没有数据绑定，那么没有数据绑定的部分被称为 Exit。示意图如下所示。 「柱形图」Bar Chart一般包括：矩形、坐标轴与文字。 矩形这里我们直接定义一个数组，用数组项对应矩形的长短（然而这种方法并不理想）。1var dataset = [50, 43, 120, 87, 99, 167, 142]; 定义一块SVG的绘制区域：1234567var width = 600; // SVG的宽度var height = 600; // SVG的长度var svg = d3.select("body") .append('svg') // body中添加SVG .attr('width', width) .attr('height', height); 定义三个我们要用的变量123var padding = &#123;top: 20, right: 20, bottom: 20, left: 20&#125;;var rectStep = 35;var rectWidth = 30; padding是svg内的最外一层区域，留一段空白宽度是为了防止图形绘制带svg区域外。rectStep表示前一个矩形到下一个矩形的距离（包括空白间隔），而rectWidth是矩形实际的宽度。说了这么多还是看图更易懂： 添加矩形元素123456789101112131415var rect = svg.selectAll("rect") .data(dataset) .enter() //获取enter部分 .append("rect") //添加rect元素，使其与绑定数组的长度一致 .attr("fill","steelblue") .attr("x",function(d,i)&#123; //设置X坐标 return padding.left + i * rectStep; &#125;) .attr("y",function(d,i)&#123; //设置Y坐标 return height - padding.bottom - d; &#125;) .attr("width",rectWidth) //设置矩形宽度，之前定义的 .attr("height",function(d)&#123; //设置矩形高度，即为数组中的各项值 return d &#125;); 因为数组dataset的长度为7，所以最后生成7个矩形。x与y坐标是矩形的左上角顶点。 这个坐标是相对应svg绘图区域来讲的，坐标原点位于左上角(0,0)。 一张图直接说明： 标签文字123456789101112131415161718var text = svg.selectAll(text) .data(dataset) .enter() .append("text") .attr("fill","white") .attr("font-size","14px") .attr("text-anchor","middle") .attr("x",function(d,i)&#123; //与矩形的X坐标一样 return padding.left + i * rectStep; &#125;) .attr("y",function(d)&#123; return height - padding.bottom - d; &#125;) .attr('dx', rectWidth/2) //x轴相对平移距离 .attr('dy', "1em") //em单位表示的是当前文字所占一行的高度 .text(function(d)&#123; //要显示的文字内容 return d; &#125;); 添加文字标签的方法与添加矩形元素方法相类似，不过颜色要与矩形的颜色区分。通过设置元素的text-anchor、x、y、dx与dy五个属性，让文字显示在每个矩形的正中心。 其中dx,dy表示相对(x,y)平移的大小，所以文本会从(x+dx,y+dy)位置开始显示，这个位置也叫起始位置。属性text-anchor有三个值：start、middle、end,，这里用middle表示文字中心位于起始位置上。 还是上图说明问题： 效果图： 坐标轴坐标轴的主直线由path构成，刻度由line绘制，刻度文字用text完成。之前我们直接用数值的大小来表示像素的大小，这里我们使用比例尺，定义如下：123456789101112131415161718192021222324// SVG画布var width = 600;var height = 600;var svg = d3.select("body").append('svg') .attr('width', width) .attr('height', height);// 坐标轴的线性比例尺var xScale = d3.scale.linear() .domain([0,10]) //定义域 .range([0,300]); //值域// 定义坐标轴var axis = d3.svg.axis() .scale(xScale) .orient("bottom") .ticks(5); //刻度的数量，这里显示5个//在 SVG 中添加一个分组元素，再将坐标轴的其他元素添加到里面var gAxis = svg.append("g") .attr("transform","translate(80,80)"); .call(axis)gAxis.attr('class', 'axis'); //添加一些样式，否则太太太丑了... call()函数的使用十分常见，这里使用的参数是前面定义的坐标轴axis，等价于axis(gAxis);的形式。效果图如下： 「柱形图的坐标轴」对初学者而言，这里的坑更多（老司机请无视）。主要是因为使用了比例尺之后，XY坐标轴、矩形长宽、刻度都要与之相对应。不要问我为什么知道这么多，都是泪…… 为矩形图定义比例尺123456789var xAxisWidth = 300; //x轴宽度var yAxisWidth = 300; //y轴宽度var xScale = d3.scale.ordinal() //x轴比例尺（序数比例尺） .domain(d3.range(dataset.length)) .rangeRoundBands([0,xAxisWidth],0.2);var yScale = d3.scale.linear() //y轴比例尺（线性比例尺） .domain([0,d3.max(dataset)]) .range([0,yAxisWidth]); 定义完比例尺之后，矩形的高度、位置都要用比例尺来计算。如此之后，仅需简单修改比例尺，图表就能自动伸缩，所以前面的矩形元素与矩形文字的代码都需要修改 矩形元素修改部分12345678910.attr("x",function(d,i)&#123; return padding.left + xScale(i); // return padding.left + i * rectStep;&#125;).attr("y",function(d,i)&#123; return height - padding.bottom - yScale(d); // return height - padding.bottom - d;&#125;).attr("width",xScale.rangeBand()) .attr("height",function(d)&#123; return yScale(d);&#125;) 标签文字修改部分1234567891011.attr("x",function(d,i)&#123; //与矩形的X坐标一样 return padding.left + xScale(i);&#125;).attr("y",function(d)&#123; return height - padding.bottom - yScale(d);&#125;).attr('dx', xScale.rangeBand()/2) //x轴相对平移距离.attr('dy', "1em") //em单位表示的是当前文字所占一行的高度.text(function(d)&#123; //要显示的文字内容 return d;&#125;); 定义坐标轴123456789var xAxis = d3.svg.axis() .scale(xScale) .orient("bottom");yScale.range([yAxisWidth,0]); //值域相反var yAxis = d3.svg.axis() .scale(yScale) .orient("left"); 此外还要注意，y轴坐标的值域要与原来相反，从最大值到最小值，否则最后会出现下面这种情况： 添加坐标轴元素1234567891011//添加x轴svg.append("g") .attr("class","axis") .attr("transform","translate(" + padding.left + "," + (height - padding.bottom) + ")") .call(xAxis);//添加y轴svg.append("g") .attr("class","axis") .attr("transform","translate(" + padding.left + "," + (height - padding.bottom - yAxisWidth) + ")") .call(yAxis); 这里要小心x轴、y轴平移到目标位置的距离，以及你设置padding前后左右的宽度，防止坐标轴跑到外面去（又是血与泪的教训）。 最后效果图： 完整源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="http://d3js.org/d3.v3.min.js" charset="utf-8"&gt;&lt;/script&gt; &lt;style&gt; .axis path, .axis line&#123; fill: none; stroke: black; shape-rendering: crispEdges; &#125; .axis text&#123; font-family: sans-serif; font-size: 11px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;script &gt; // 添加SVG画布 var dataset = [50, 43, 120, 87, 99, 167, 142]; var width = 600; // SVG的宽度 var height = 600; // SVG的长度 var svg = d3.select("body") .append('svg') // body中添加SVG .attr('width', width) .attr('height', height); var padding = &#123;top: 20, right: 20, bottom: 20, left: 30&#125;; // 定义数据与比例尺 var xAxisWidth = 300; //x轴宽度 var yAxisWidth = 300; //y轴宽度 var xScale = d3.scale.ordinal() //x轴比例尺（序数比例尺） .domain(d3.range(dataset.length)) .rangeRoundBands([0,xAxisWidth],0.2); var yScale = d3.scale.linear() //y轴比例尺（线性比例尺） .domain([0,d3.max(dataset)]) .range([0,yAxisWidth]); // 添加矩形和文字元素 var rect = svg.selectAll("rect") .data(dataset) .enter() //获取enter部分 .append("rect") //添加rect元素，使其与绑定数组的长度一致 .attr("fill","steelblue") .attr("x",function(d,i)&#123; //设置X坐标 // return padding.left + i * rectStep; return padding.left + xScale(i); &#125;) .attr("y",function(d,i)&#123; //设置Y坐标 // return height - padding.bottom - d; return height - padding.bottom - yScale(d); &#125;) .attr("width",xScale.rangeBand()) //设置矩形宽度 .attr("height",function(d)&#123; return yScale(d); &#125;) var text = svg.selectAll(text) .data(dataset) .enter() .append("text") .attr("fill","white") .attr("font-size","14px") .attr("text-anchor","middle") .attr("x",function(d,i)&#123; //与矩形的X坐标一样 return padding.left + xScale(i); &#125;) .attr("y",function(d)&#123; return height - padding.bottom - yScale(d); &#125;) .attr('dx', xScale.rangeBand()/2) //x轴相对平移距离 .attr('dy', "1em") //em单位表示的是当前文字所占一行的高度 .text(function(d)&#123; //要显示的文字内容 return d; &#125;); // 定义坐标轴 var xAxis = d3.svg.axis() .scale(xScale) .orient("bottom"); yScale.range([yAxisWidth,0]); var yAxis = d3.svg.axis() .scale(yScale) .orient("left"); // 添加坐标轴 svg.append("g") .attr("class","axis") .attr("transform","translate(" + padding.left + "," + (height - padding.bottom) + ")") .call(xAxis); svg.append("g") .attr("class","axis") .attr("transform","translate(" + padding.left + "," + (height - padding.bottom - yAxisWidth) + ")") .call(yAxis); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 「参考资料」 【Learning D3.JS】 【D3.js：Update、Enter、Exit】 【D3.js - 初体验】 【D3.js数据可视化系列教程】]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Semantic UI上手]]></title>
      <url>%2F2017%2F03%2F18%2FSemantic-UI%E4%B8%8A%E6%89%8B%2F</url>
      <content type="text"><![CDATA[最近使用Semantic UI这一CSS框架实现了上图的苹果静态官网首页，我只想说，要不要这么简单粗暴！它省去了你大量时间与经历，不必去重复造轮子。但如此的便利必然是付出了某种你还未发现的代价…… Semantic UI基础知识我们要了解一些基本的样式与技巧，并能通过使用“形容词”来改变样式。 【基本样式】首先，header中导入semantic样式，在body的div块中定义class=“ui segment”，基本效果如下 【使用“形容词”】其次，在div class = &quot;XXX&quot;中加上你想实现的“形容词” inverted + color vertical padded inverted 颜色反转，若不加颜色，则直接变成黑色，官网给出下面多种颜色选择 vertical消除两边的圆角、阴影，同一vertical作用下的多个segment之间缝隙消失， padded改变内距 Apple静态官网首页实现了解了必要的知识之后，赶紧来实践一番！ 【导航菜单栏】使用semantic自带的ui menu样式，第一个与最后两个使用图标插入，其余的直接输文字，这里有几个小点需要注意： fixed：固定菜单栏，下拉拖动时表头不会消失，一直悬浮在最上面 fitted：大小宽度自适应 nine item：九个图标居中显示 borderless：去除图案之间的白色间隔线 代码如下1234567891011121314151617181920212223&lt;div class="ui fixed fitted inverted borderless nine item menu"&gt; &lt;a href="#" class="item"&gt; &lt;div class="ui image"&gt; &lt;img src="images\appleicon.png" alt="" /&gt; &lt;/div&gt; &lt;/a&gt; &lt;a href="#" class="item"&gt;Mac&lt;/a&gt; &lt;a href="#" class="item"&gt;iPad&lt;/a&gt; &lt;a href="#" class="item"&gt;iPhone&lt;/a&gt; &lt;a href="#" class="item"&gt;Watch&lt;/a&gt; &lt;a href="#" class="item"&gt;Music&lt;/a&gt; &lt;a href="#" class="item"&gt;技术支持&lt;/a&gt; &lt;a href="#" class="item"&gt; &lt;div class="ui image"&gt; &lt;img src="images\searchicon.png" alt="" /&gt; &lt;/div&gt; &lt;/a&gt; &lt;a href="#" class="item"&gt; &lt;div class="ui image"&gt; &lt;img src="images\buyicon.png" alt="" /&gt; &lt;/div&gt; &lt;/a&gt;&lt;/div&gt; 【iPhone7大图】 使用ui image样式插入图片，其他注意点： basic：消除黑边 secondary：相当于下面的效果 但是在这里可以从视觉效果上去除图片下的底色，否则会是下面这样，要多难看有多难看… 代码如下12345&lt;div class="ui basic secondary vertical segment"&gt; &lt;div class="ui image"&gt; &lt;img src="images/banner.png" alt="" /&gt; &lt;/div&gt;&lt;/div&gt; 【四张小图】 代码如下12345678910111213141516&lt;div class="ui basic secondary vertical segment"&gt; &lt;div class="ui fitted text menu"&gt; &lt;div class="item"&gt; &lt;img class="ui image" src="images/img1.png" alt="" /&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;img class="ui image" src="images/img2.png" alt="" /&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;img class="ui image" src="images/img3.png" alt="" /&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;img class="ui image" src="images/img4.png" alt="" /&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 【最后文字】 使用嵌套制作网页ui segment -&gt; ui container，注意事项： very padded：内距变大 一条分割线：通过&lt;div class=&quot;ui divider&quot;&gt;&lt;/div&gt;方式“画出”一条分割线 grid：网格系统，使用five column分成五列 text menu：每段文字放在里面，且用vertical垂直排列 代码如下12345678910111213141516171819202122232425&lt;div class="ui vertical secondary very padded segment"&gt; &lt;div class="ui container"&gt; &lt;div class="sub header"&gt; 双镜头摄像头仅于 iPhone 7 Plus 提供。亮黑色外观仅于 128GB 及以上存储容量的机型提供。 &lt;/div&gt; &lt;div class="ui divider"&gt;&lt;/div&gt; &lt;div class="ui five column grid"&gt; &lt;div class="column"&gt; &lt;div class="ui vertical text menu"&gt; &lt;div class="item"&gt; &lt;h4&gt;Apple Store 商店&lt;/h4&gt; &lt;/div&gt; &lt;a class="item"&gt;查找零售店&lt;/a&gt; &lt;a class="item"&gt;iPad&lt;/a&gt; &lt;a class="item"&gt;iPhone&lt;/a&gt; &lt;a class="item"&gt;Watch&lt;/a&gt; &lt;a class="item"&gt;iPod&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 段落重复4遍ing --&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 好了，最后把‘导航菜单栏’、‘iPhone7大图’、‘四张小图’与‘最后文字’四块部分拼接起来，就实现了苹果官网首页的效果，耶~ 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;Apple&lt;/title&gt; &lt;link rel="stylesheet" href="css/semantic.css" media="screen" title="no title" charset="utf-8"&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 导航栏 --&gt; &lt;div class="ui fixed fitted inverted borderless nine item menu"&gt; &lt;a href="#" class="item"&gt; &lt;div class="ui image"&gt; &lt;img src="images\appleicon.png" alt="" /&gt; &lt;/div&gt; &lt;/a&gt; &lt;a href="#" class="item"&gt;Mac&lt;/a&gt; &lt;a href="#" class="item"&gt;iPad&lt;/a&gt; &lt;a href="#" class="item"&gt;iPhone&lt;/a&gt; &lt;a href="#" class="item"&gt;Watch&lt;/a&gt; &lt;a href="#" class="item"&gt;Music&lt;/a&gt; &lt;a href="#" class="item"&gt;技术支持&lt;/a&gt; &lt;a href="#" class="item"&gt; &lt;div class="ui image"&gt; &lt;img src="images\searchicon.png" alt="" /&gt; &lt;/div&gt; &lt;/a&gt; &lt;a href="#" class="item"&gt; &lt;div class="ui image"&gt; &lt;img src="images\buyicon.png" alt="" /&gt; &lt;/div&gt; &lt;/a&gt; &lt;/div&gt; &lt;!-- 表头图片 --&gt; &lt;div class="ui basic secondary vertical segment"&gt; &lt;div class="ui image"&gt; &lt;img src="images/banner.png" alt="" /&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 四张图、 --&gt; &lt;div class="ui basic secondary vertical segment"&gt; &lt;div class="ui fitted text menu"&gt; &lt;div class="item"&gt; &lt;img class="ui image" src="images/img1.png" alt="" /&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;img class="ui image" src="images/img2.png" alt="" /&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;img class="ui image" src="images/img3.png" alt="" /&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;img class="ui image" src="images/img4.png" alt="" /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 最后文字 --&gt; &lt;div class="ui vertical secondary very padded segment"&gt; &lt;div class="ui container"&gt; &lt;div class="sub header"&gt; 双镜头摄像头仅于 iPhone 7 Plus 提供。亮黑色外观仅于 128GB 及以上存储容量的机型提供。 &lt;/div&gt; &lt;!-- 文字重复中 --&gt; &lt;div class="ui divider"&gt;&lt;/div&gt; &lt;div class="ui five column grid"&gt; &lt;div class="column"&gt; &lt;div class="ui vertical text menu"&gt; &lt;div class="item"&gt; &lt;h4&gt;Apple Store 商店&lt;/h4&gt; &lt;/div&gt; &lt;a class="item"&gt;查找零售店&lt;/a&gt; &lt;a class="item"&gt;iPad&lt;/a&gt; &lt;a class="item"&gt;iPhone&lt;/a&gt; &lt;a class="item"&gt;Watch&lt;/a&gt; &lt;a class="item"&gt;iPod&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="column"&gt; &lt;div class="ui vertical text menu"&gt; &lt;div class="item"&gt; &lt;h4&gt;Apple Store 商店&lt;/h4&gt; &lt;/div&gt; &lt;a class="item"&gt;查找零售店&lt;/a&gt; &lt;a class="item"&gt;iPad&lt;/a&gt; &lt;a class="item"&gt;iPhone&lt;/a&gt; &lt;a class="item"&gt;Watch&lt;/a&gt; &lt;a class="item"&gt;iPod&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="column"&gt; &lt;div class="ui vertical text menu"&gt; &lt;div class="item"&gt; &lt;h4&gt;Apple Store 商店&lt;/h4&gt; &lt;/div&gt; &lt;a class="item"&gt;查找零售店&lt;/a&gt; &lt;a class="item"&gt;iPad&lt;/a&gt; &lt;a class="item"&gt;iPhone&lt;/a&gt; &lt;a class="item"&gt;Watch&lt;/a&gt; &lt;a class="item"&gt;iPod&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="column"&gt; &lt;div class="ui vertical text menu"&gt; &lt;div class="item"&gt; &lt;h4&gt;Apple Store 商店&lt;/h4&gt; &lt;/div&gt; &lt;a class="item"&gt;查找零售店&lt;/a&gt; &lt;a class="item"&gt;iPad&lt;/a&gt; &lt;a class="item"&gt;iPhone&lt;/a&gt; &lt;a class="item"&gt;Watch&lt;/a&gt; &lt;a class="item"&gt;iPod&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="column"&gt; &lt;div class="ui vertical text menu"&gt; &lt;div class="item"&gt; &lt;h4&gt;Apple Store 商店&lt;/h4&gt; &lt;/div&gt; &lt;a class="item"&gt;查找零售店&lt;/a&gt; &lt;a class="item"&gt;iPad&lt;/a&gt; &lt;a class="item"&gt;iPhone&lt;/a&gt; &lt;a class="item"&gt;Watch&lt;/a&gt; &lt;a class="item"&gt;iPod&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 参考资料 Semantic UI 官网Semantic UI 中文文档]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[如何成为技术大牛]]></title>
      <url>%2F2017%2F03%2F15%2F%E5%A6%82%E4%BD%95%E6%88%90%E4%B8%BA%E6%8A%80%E6%9C%AF%E5%A4%A7%E7%89%9B%2F</url>
      <content type="text"><![CDATA[前几日朋友分享了一篇“技术大牛养成指南”，看完之后有种豁然开朗的感觉，这也许和我最近的状态有关，最近一直没想通的问题似乎在这篇文章中也得到解决。作者通过目标拆解，用可实践的方法来指导大家如何在日常生活与工作中去运用。 什么是1万小时理论成为顶级专家的唯一方法就是1万小时持续不断地练习，意味着每天如果花3小时来提升自己的技能，需要10年…（不能包括你每天的重复性工作时间，要从专业广度与深度上不断扩展） 如何找到1万小时 每天的起床前与睡前30分钟：你会感到每天平白无故比别人多了一、两个小时 利用或节省路途时间 周末4小时 如何坚持下去 分解等级 0~1年：菜鸟，需要手把手教 1~3年：初级，要别人带你 3~5年：高级，独挡一面，能带初级技术人员 5~8年：资深，独挡多面 8~10年：大牛，统筹规划，高屋建瓴 分解技能每一段目标持续2~3年，哪里不懂补哪里，最好以6个月为周期 分解行动把技能目标分解为具体要做的事，把6个月的目标分解为1个月的目标 如何在工作中提升自我掌握业务代码中的技术后期并不会让你提升经验值，必须打更高级的怪、刷副本，没有一直打小怪就能升到顶级。你要不断的提升自己的水平，然后面临更大的挑战，从而使自己水平更上一级。 Do more 去熟悉更多系统、业务、代码，不管是不是你所负责的 善于自学。「唯一不变的只有变化」，我们更加需要自学更多东西，因为真正等到要用的时候再来学已经没有时间了 Do better你负责的系统和业务，总有不合理和可以改进的地方。这些“不合理”和“可改进”的地方，都是更高级别的怪物，打完后能够增加更多的经验值。 Do exercise印第安人有一句谚语：I hear and I forget. I see and I remember. I do and I understand.其实方法很简单：learning、trying、teaching]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《大数据与机器学习》读书笔记（一） 数据与数据平台]]></title>
      <url>%2F2017%2F03%2F12%2F%E3%80%8A%E5%A4%A7%E6%95%B0%E6%8D%AE%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%20%E6%95%B0%E6%8D%AE%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%B9%B3%E5%8F%B0%2F</url>
      <content type="text"><![CDATA[数据环境与数据形态对于企业经营中产生的数据有三种形态： 生产数据：指某个生产系统的生产环境数据库中的数据。它会随着业务应用的变化而变化，是动态的，如用户的账户余额数据。 原始数据：对生产数据的解耦，包括数据脱敏、字段筛选、批量导出（将动态数据的“快照”保存下来）。其目的是为了防止生产数据与分析数据的数据直连，带来数据管理与应用的灾难 分析数据：对原始数据进行ETL之后的数据，主要从属性筛选、标准统一（如数据格式与字段含义的不一致）、优化存储（如创建索引，分区，分表存储）的角度进行ETL。 数据仓库平台数仓本质是解决大批量数据的入口与出口问题，为分析与应用提供支持。该书作者认为能稳定提供 “顺滑” 数据服务的数仓需要注下面两点： 更新规则： 分全量更新与增量更新两种方式。更新过程中要注意“部分提交”与“数据断档”问题，可行的解决方案是增加中间表，如图 存储规则： 分析发现，数仓用户使用的交易数据90%集中在近三个月，60%的作业仅集中在近一个月。所以可行的办法是“大表拆小表，小表组视图”，提高访问效率。 大数据平台之前一直把Hive与Hbase的概念混淆，趁此机会搞清楚。 Hbase Hive 基于HDFS的非关系型数据库（KV型） 关系型数据结构，是用SQL替代写MR的编程框架 物理表，适合存放非结构化的数据 纯逻辑表，本身不存储数据，完全依赖于HDFS和MR 处理数据是基于列的模式 基于MR处理数据,而MR是基于行的模式 HBase是为了支持弥补Hadoop对实时操作的缺陷的项目 Hive是建立在Hadoop之上为了减少MapReduce jobs编写工作的批处理系统 适合实时查询 适合查询分析统计]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[matplotlib绘图－斜上抛运动]]></title>
      <url>%2F2017%2F03%2F11%2Fmatplotlib%E8%BF%90%E7%94%A8%EF%BC%8D%E6%96%9C%E4%B8%8A%E6%8A%9B%E8%BF%90%E5%8A%A8%2F</url>
      <content type="text"><![CDATA[matplotlib是Python中绘制2D图形使用最多的库，可以很轻松的将数据图形化。本文绘制了斜上抛运动，下面是最终的效果。 （菲菲老师教得好，幸不辱命 (•‾̑⌣‾̑•)✧˖° ） 「准备工作」 导入所需数据包这里的animation.FuncAnimation（fig，update，generate，interval = 5）函数，是用于生成动态图片的。其中fig表示生成的图表对象；generate函数生成数据后传递给update函数更新，这样数据不断更新，图形也不停变化；interval表示时间间隔，设置的值越小，运动速度越快 123from matplotlib import pyplot as pltfrom matplotlib import animation import math 设置图形窗口参数 12345678910111213141516# 中文字体路径设置，防止中文不显示font=FontProperties(fname=r"c:\windows\fonts\simsun.ttc",size=14)# 初始化图形窗口fig = plt.figure()ax = fig.add_subplot(111) ax.set_aspect('equal')# 设置坐标轴的x,y取值范围xmin = 0ymin = 0ax = plt.axes(xlim = (xmin, xmax), ylim = (ymin, ymax)) # 创建一个圆，圆点在（0,0），半径为1circle = plt.Circle((xmin, ymin), 1)ax.add_patch(circle) 给定初始参数值 1234g = 9.8u = 30 # 斜上抛的初速度theta = 60 # 与水平方向的夹角θtheta_radians = math.radians(theta) # 返回一个角度的弧度值 计算衍生参数 1234t_flight= 2*u*math.sin(theta_radians)/g # 从A点到B点所需时间t_max = u*math.sin(theta_radians)/g # 上升到最大高度所需时间xmax = u*math.cos(theta_radians)*t_flight # AB两点的距离ymax = u*math.sin(theta)*t_max - 0.5*g*t_max**2 # 上升的最大高度 「制作动态效果」主要利用前面介绍的animation.FuncAnimation函数。于是我们需要构造generate与update函数，让它动起来~ generate函数123456#产生时间间隔参数（每个数据间隔为0.05），依次传递给updata函数 def generate(): t = 0 while t &lt; t_flight: t += 0.05 yield t update函数123456#更新时间间隔参数，从而不断改变圆的圆心坐标位置，让其移动 def update(t): x = u*math.cos(theta_radians)*t y = u*math.sin(theta_radians)*t - 0.5*g*t*t circle.center = x, y return circle, 打印相关信息12345def Print(): print (u"初始速度（米/秒）:",u) print (u"发射角度（度）",theta) print (u"飞行总时间（秒）",t_flight) print (u"飞行距离（米）",xmax) 动画函数123456789anim = animation.FuncAnimation(fig, update,generate,interval=10)# 附加信息anim= animation.FuncAnimation(fig, update,generate,interval=10)plt.title(u'导弹发射轨迹',fontproperties=font)plt.xlabel(u'水平距离(米)',fontproperties=font)plt.ylabel(u'导弹运行高度（米）',fontproperties=font)plt.show()Print() 最后就能看到首页的动态图了 ヾ(◍’౪`◍)ﾉﾞ]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[R数据可视化－动态、交互式地图神器（三）自定义Marker]]></title>
      <url>%2F2017%2F03%2F08%2FR%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%EF%BC%8D%E5%8A%A8%E6%80%81%E3%80%81%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%9C%B0%E5%9B%BE%E7%A5%9E%E5%99%A8%EF%BC%88%E4%B8%89%EF%BC%89%E7%AC%A6%E5%8F%B7%E6%A0%87%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[Leaflet/LeafletCN 系列R数据可视化－动态、交互式地图神器（一）概述与实现R数据可视化－动态、交互式地图神器（二）地图与定位 特别喜欢Leaflet的marker自定义，主要有以下几种标记方法 【标记】 addMarkers(popup,icon) awesomeMarker(icon,library, markerColor,iconColor ) addCircleMarker(popup,color,fillOpacity) 1234567891011- popup：文字描述- icon：自定义图标- icon：图表类型- library：图标库- markerColor：背景颜色- iconColor ：图标颜色- popup：文字描述- color：颜色- fillOpacity：透明度 【第一类方法举例】123456df = data.frame(Lat = 31+ rnorm(10,0,1), Lon = 121 + rnorm(10,0,1)) # 生成10个随机点df #传数据 %&gt;% leaflet() # 加载地图容器 %&gt;% addTiles() # 加载底图 %&gt;% addMarkers() # 加默认标记 这种是默认的图标 接下来自定义icon12345678910111213warIcons &lt;- iconList( #自定义icon图标 cat = makeIcon("cat.png", iconWidth = 60, iconHeight = 60, iconAnchorX = 30, iconAnchorY = 30), dog = makeIcon("dog.png", iconWidth = 60, iconHeight = 60, iconAnchorX = 30, iconAnchorY = 30)) geo %&gt;% leaflet() #加地图容器 %&gt;% addProviderTiles("Thunderforest.SpinalMap") #加地图底图 %&gt;% addMarkers(icon=~warIcons[type]) #使用自定义的icon 其中geo数据长这样 其中makeIcon用法123456makeIcon(iconUrl ,iconWidth,iconHeight,iconAnchorX ,iconAnchorY) - iconUrl : 图标的url地址 - iconWidth ：图标的宽度 - iconHeight: 图标的高度 - iconAnchorX :图标的中心点x轴偏移（以左上角为0,0) - iconAnchorY :图标的中心点Y轴偏移（以左上角为0,0) 效果 【第二类方法举例】可以在library参数中设定你希望选择的图标库，有以下几个： fontIcons glyphicon Ionicons 如：1234567myIcon = makeAwesomeIcon(icon = "book", library = "glyphicon",markerColor = "purple")df%&gt;% leaflet() %&gt;% setView() %&gt;% addProviderTiles("NASAGIBS.ViirsEarthAtNight2012") %&gt;% addAwesomeMarkers(icon=myIcon) 效果 【第三类方法举例】addCircleMarkers()方法更简单，直接把点作为一个镶边的圆（或者说圆符号）绘制到地图上，如：123leaflet(df) %&gt;% addProviderTiles("CartoDB.Positron")%&gt;% addCircleMarkers() 效果]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo搭建个人博客]]></title>
      <url>%2F2017%2F03%2F05%2FHexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[前言人啊，总有那么一瞬间，想把自己各种美好与不美好的瞬间，经历与感悟给记录下来。当自己回过头再来看的时候，也许会哭，会笑，酸甜苦辣，各有滋味。当这些点点滴滴汇聚起来之后，估计我会仰天大吼：这一世没白活！ 正文这个周末在网上各种找资料、跨过无数坑之后，个人博客算是初步完成了。 【目标与要求】 美观：对审美有一定要求，有相对不错的外观 功能：起码能分类、打标签、各种时间维度能归档 学习成本：语言、代码相对更容易，学习成本相对较低 时间与金钱成本：最好不用花钱（能省点是一点，我的土壕朋友请无视），不用花太多时间在系统运维 【产品选型】 第三方博客平台，如CSDN、博客园、新浪、豆瓣等。可直接写文章，但模板、样式固定，不算难看也不算好看（简书整体不错，简约风，但是不能带标签，而且鸡汤较多…） 博客工具，部分支持MarkDown语法，免去把文本转化为HTML的痛苦，主要有： wordpress：功能强大，要有主机与域名（免费有限制，正经使用的要花钱购买、备案，还要考虑审批部门的效率…你懂的），折腾太费事费时 ghost：类似wordpress，相对较重，也是动态网站、需要依赖数据库 Jekyll：静态文件生成器，支持Markdown，能部署到github。依赖较多库，windows用户不友好，无本地预览功能 hexo：安装简单，依赖少（仅node），中文支持好（台湾人写的），命令少，易于记忆，可本地实现简单预览，支持markdown。 果断选择了Hexo，下面是介绍下主角： “A fast, simple &amp; powerful blog framework, powered by Node.js.”（官方版）。它是一个Node的静态博客框架，因此没有数据库。可直接部署到github上。好处大大的：省去服务器成本，减少系统运维(系统管理、备份、网络)。 【安装操作】 安装node.js：用来生成静态页面[点击安装node] 注册Github账号：欢迎加入全球最大的同性交友网站ヾ(◍’౪`◍)ﾉﾞ。不限流量、免费提供开放的托管静态页面的网站。 注意！新建的Repo一定要与你的github用户名一模一样，如[username].github.io 安装Git：用于把本地的Hexo内容沟通,传输,部署到Github上。安装教程可参考廖雪峰的博客[点击安装Git] 以下步骤一定要做！ 12$ git config --global user.name "Your Name"$ git config --global user.email "email@example.com" 安装Hexo 在git bash中敲： 1npm install hexo-cli -g 【构建博客】 初始化 创建一个新的文件夹（放你博客的地方），右键点击Git Bash Here，执行： 1hexo init 可以通过以下命令查看是否执行成功 1hexo s 出现以下代码，恭喜成功~，并在浏览器输入：http://localhost:4000/ 进行本地预览（默认端口4000） 12INFO Start processingINFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 配置与部署 我们看到之前创建的博客所在文件夹结构： Blog ｜ ｜－－ .deploy_git ｜－－ node_modules ｜－－ scaffolds ｜－－ source ｜－－ themes ｜－－ _config.yml ｜－－ _gitinore ｜－－ db.json ｜－－ package.json ｜－－ debug.log 现在需要_config.yml与我们github用户名对应的仓库建立联系。打开_config.yml文件，拉到最后对应修改： 123deploy:type: gitrepo: http://github.com/[username]/[username].github.io 并部署： 123hexo clean # 清除缓存hexo generate # 生成静态页面hexo deploy # 上传部署 到现在，我们的“简装房”就有了，后续需要通过主题替换与各种功能设置，来鸟枪换大炮，变成“精装房”(▰˘◡˘▰) ~。 参考资料 Hexo 中文文档 【包涵：文档、API、插件、主题】NexT 使用文档【包含：开始使用、主题配置、第三方服务、内建标签、常见问题】]]></content>
    </entry>

    
  
  
</search>
